# BFS / DFS

## 설명

- BFS / DFS 는 대표적인 그래프 탐색 알고리즘
- 너비 우선 탐색 (Breadth First Search): 정점들과 같은 레벨에 있는 노드들을 먼저 탐색하는 방식
- 깊이 우선 탐색 (Depth First Search): 정점의 자식들을 먼저 탐색하는 방식, 자기 자신을 호출하는 순환 알고리즘의 형태를 갖는다.

## 탐색 순서

`BFS`

<img src="https://user-images.githubusercontent.com/28842641/125909250-506fad7f-05c9-42c1-a00f-3eafa1274511.png"/>

> A -> B -> C -> D -> G -> H -> I -> E -> F -> J

`DFS`

> 1. A -> B -> D -> E -> F -> C -> G -> H -> I -> J
> 2. A -> C -> I -> J -> H -> G -> B -> D -> F -> E

## 표현 방법

- 파이썬의 경우 dict, 자바스크립트의 경우 { }를 사용하여 나타낸다.
- key, value 쌍으로 구분하며 key에는 노드를 value에는 연결되는 노드들을 배열로 묶어서 넣는다.

## 구현 방법

### BFS

1. 방문한 노드를 담을 `큐`와 방문 예정인 노드를 담을 `큐`를 만든다.
2. 처음에 루트 노드를 방문 예정인 큐에 담는다.
3. 방문 예정인 노드를 담은 큐에서 가장 앞에거를 꺼내서 방문한 노드를 담는 큐에 넣는다. (만약 해당 노드가 방문한 기록이 있다면 방문한 노드를 담는 큐에 넣지 않는다.)
4. 만약 방문하지 않은 노드라면 방문한 노드를 담는 큐에 넣고, 인접 노드들을 방문 예정인 노드를 담는 큐에 넣는다.
5. 위 과정을 방문 예정인 노드를 담는 큐에 아무것도 없을 때까지 반복한다.

### DFS

- BFS 와 동일한 방식으로 작동하나, 방문 예정인 노드를 담는 리스트가 큐가 아닌 `스택` 이다.

## 장점

### BFS

1. 노드의 수가 적고 깊이가 얕은 경우 빠르게 동작할 수 있다.
2. 단순 검색 속도가 깊이 우선 탐색(DFS) 보다 빠르다.
3. 너비 우선 탐색을 하기 때문에 답이 되는 경로가 여러개인 경우에도 최단 경로임을 보장한다.
4. 최단 경로가 존재한다면 어느 한 경로가 무한히 깊어진다 해도 최단 경로를 반드시 찾을 수 있다.

### DFS

1. 현 경로상의 노드들만 기억하면 되기 때문에, 그래프의 높이 만큼의 공간만을 요구한다.

## 단점

### BFS

1. 재귀 호출의 DFS와는 달리 큐에 탐색할 정점들을 저장해야 하므로 저장 공간이 많이 필요하다.
2. 노드의 수가 늘어나면 탐색해야 하는 노드 또한 많이지기에 비현실적이다.

### DFS

1. 얻어진 해가 최단 경로가 된다는 보장이 없다.

## 시간 복잡도

- 노드의 수 : V
- 간선의 수 : E
- 앞서 언급한 반복문은 V + E 만큼 수행된다.
  `O(V + E)`
