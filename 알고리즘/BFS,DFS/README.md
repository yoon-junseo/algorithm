# BFS / DFS

## 설명

- BFS / DFS 는 대표적인 그래프 탐색 알고리즘
- 너비 우선 탐색 (Breadth First Search): 정점들과 같은 레벨에 있는 노드들을 먼저 탐색하는 방식
- 깊이 우선 탐색 (Depth First Search): 정점의 자식들을 먼저 탐색하는 방식, 자기 자신을 호출하는 순환 알고리즘의 형태를 갖는다.

## 탐색 순서

<img src="https://user-images.githubusercontent.com/28842641/125909250-506fad7f-05c9-42c1-a00f-3eafa1274511.png"/>

`BFS`

> A -> B -> C -> D -> G -> H -> I -> E -> F -> J

`DFS`

> 1. A -> B -> D -> E -> F -> C -> G -> H -> I -> J
> 2. A -> C -> I -> J -> H -> G -> B -> D -> F -> E

## 표현 방법

- 파이썬의 경우 dict, 자바스크립트의 경우 { }를 사용하여 나타낸다.
- key, value 쌍으로 구분하며 key에는 노드를 value에는 연결되는 노드들을 배열로 묶어서 넣는다.

## 그래프 표현 방법

### 인접 행렬

- 2차원 배열로 그래프의 연결 관계를 표현하는 방식

```python
INF = 999999

graph = [
  [0, 7, 5],
  [7, 0, INF],
  [5, INF, 0]
]
```

### 인접 리스트

- 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결해서 표현하는 방식

```python
graph = [[] for _ in range(3)]

# 노드 0에 연결된 노드 정보 저장 (노드, 거리)
graph[0].append((1, 7)) # 0 - 1 사이에 7만큼의 거리
graph[0].append((2, 5))

graphp[1].append((0, 7))

graph[2].append((0, 5))
```

> 인접 행렬 방식은 노드 개수가 많을수록 메모리가 낭비된다. 인접 리스트 방식은 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느리다. (연결된 데이터를 하나씩 확인해야 하기 때문이다.)

## 구현 방법

### BFS

1. 방문한 노드를 담을 `큐`와 방문 예정인 노드를 담을 `큐`를 만든다.
2. 처음에 루트 노드를 방문 예정인 큐에 담는다.
3. 방문 예정인 노드를 담은 큐에서 가장 앞에거를 꺼내서 방문한 노드를 담는 큐에 넣는다. (만약 해당 노드가 방문한 기록이 있다면 방문한 노드를 담는 큐에 넣지 않는다.)
4. 만약 방문하지 않은 노드라면 방문한 노드를 담는 큐에 넣고, 인접 노드들을 방문 예정인 노드를 담는 큐에 넣는다.
5. 위 과정을 방문 예정인 노드를 담는 큐에 아무것도 없을 때까지 반복한다.

---

1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.

### DFS

- BFS 와 동일한 방식으로 작동하나, 방문 예정인 노드를 담는 리스트가 큐가 아닌 `스택` 이다.

1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.

## 장점

### BFS

1. 노드의 수가 적고 깊이가 얕은 경우 빠르게 동작할 수 있다.
2. 단순 검색 속도가 깊이 우선 탐색(DFS) 보다 빠르다.
3. 너비 우선 탐색을 하기 때문에 답이 되는 경로가 여러개인 경우에도 최단 경로임을 보장한다.
4. 최단 경로가 존재한다면 어느 한 경로가 무한히 깊어진다 해도 최단 경로를 반드시 찾을 수 있다.

### DFS

1. 현 경로상의 노드들만 기억하면 되기 때문에, 그래프의 높이 만큼의 공간만을 요구한다.

## 단점

### BFS

1. 재귀 호출의 DFS와는 달리 큐에 탐색할 정점들을 저장해야 하므로 저장 공간이 많이 필요하다.
2. 노드의 수가 늘어나면 탐색해야 하는 노드 또한 많이지기에 비현실적이다.

### DFS

1. 얻어진 해가 최단 경로가 된다는 보장이 없다.

## 시간 복잡도

- 노드의 수 : V
- 간선의 수 : E
- 앞서 언급한 반복문은 V + E 만큼 수행된다.
  `O(V + E)`

## 정리

|           | DFS       | BFS         |
| --------- | --------- | ----------- |
| 동작 원리 | 스택      | 큐          |
| 구현 방법 | 재귀 함수 | 큐 자료구조 |
